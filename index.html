<html>
  <head>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <title>World Level</title>
    <style>
      :root {
        --level-0: #ececec;
        --level-1: #d6beff;
        --level-2: #88aeff;
        --level-3: #a8ffbe;
        --level-4: #ffe57e;
        --level-5: #ffb57e;
        --level-6: #ff7e7e;
      }

      body {
        font-family: sans-serif;
        font-size: 1.5rem;
      }

      #scores {
        width: 20rem;
        position: fixed;
        top: 40rem;
        left: 10rem;
        & > div > span:last-child {
          float: right;
        }
      }
      #label {
        background-color: #fff;
      }

      h1 {
        text-align: center;
      }
    </style>
    <script>
      const colors = [
        "#ececec",
        "#d6beff",
        "#88aeff",
        "#a8ffbe",
        "#ffe57e",
        "#ffb57e",
        "#ff7e7e",
      ];
      const points = [0, 0, 1, 2, 3, 4, 5];
      const WIDTH = 2000;
      const HEIGHT = 867;
      const IMG_WIDTH = 2000;
      const IMG_HEIGHT = 867;
      const DEFAULT_OUTLINE_STROKE = 1;
      const HEAVY_OUTLINE_STROKE = 3;
      // Generate a random color for the background that should be uniquish per map
      function colorFromLevelMap(levels) {
        // need to start with a seed number, probably better would be to hash
        // the levels object, but this makes every choice change the color differently
        // so that's decent
        const seed = Object.values(levels).reduce(
          (acc, cur, i) => (acc += cur * i),
          0
        );
        // this is some random number generator i took from stack overflow
        // without remembering to write down the source or what it's called
        let a = seed;
        const rand = () => {
          a |= 0;
          a = (a + 0x9e3779b9) | 0;
          let t = a ^ (a >>> 16);
          t = Math.imul(t, 0x21f0aaad);
          t = t ^ (t >>> 15);
          t = Math.imul(t, 0x735a2d97);
          return ((t = t ^ (t >>> 15)) >>> 0) / 4294967296;
        };

        return `#${[0, 0, 0]
          .map(() =>
            (Math.floor(rand() * 50) + 176).toString(16).padStart(2, "0")
          )
          .join("")}`;
      }

      // load the world and put in the event listeners
      async function loadWorld() {
        const svg = document.createElement("div");
        svg.innerHTML = await fetch("./world2.svg").then((r) => r.text());
        document.querySelector("body").appendChild(svg);

        const scoreEl = document.getElementById("scores");
        const svgScoreEls = document.querySelectorAll(".legend");

        // extract a list of country names from the world svg
        const countries = [
          ...new Set(
            Array.from(document.querySelector("svg").children).flatMap((e) =>
              e.id && e.attributes.name?.value
                ? [e.attributes.name.value]
                : e.id
                ? []
                : [e.className.baseVal]
            )
          ),
        ];

        // returns an array of elements which constitute all the SVG paths
        // for the country with the given name
        const getCountryPaths = (n) => {
          try {
            return Array.from(
              document.querySelectorAll(
                // countries bound in a single path are given a name attribute
                // countries spread across multiple paths are given a className
                `[name='${n}'],.${n.replaceAll(" ", ".")}`
              )
            ).filter(
              (e) => e.attributes.name?.value === n || e.className.baseVal === n
            );
          } catch {
            return [];
          }
        };

        // set the color of the given country appropriate to the country-level
        const setColor = (countryName, level) =>
          getCountryPaths(countryName).forEach((e) => {
            e.setAttribute("fill", colors[level]);
          });

        // generate a window.location.hash string uniquely identifying the
        // current level map by grouping countries by level if their level is greater
        // than 0, separating the groups by `;` and encoding individual countries
        // in each group as two-character hex strings representing their index
        // in the country map.
        // breaks if the country list changes, so maybe not the best for a rapidly
        // evolving world
        const hashOf = (levels) => {
          let h = "#";

          for (const level of [1, 2, 3, 4, 5, 6]) {
            h +=
              Object.values(levels)
                .flatMap((l, i) =>
                  l == level ? [i.toString(16).padStart(2, "0")] : []
                )
                .join("") + ";";
          }
          return h;
        };
        // total score
        let score = 0;

        // return a map of country name to level by parsing the window.location.hash
        // defaults to all countries mapping to 0. Inverse of hashOf
        // also updates the title text with the appropriate score, and
        // sets the color of each country and the background
        const getLevels = () => {
          const l = Object.fromEntries(countries.map((c, i) => [c, 0]));
          try {
            // tis me: #;032343;;;181920262f45484c4d5e888e9ea2;3f6aa3;
            window.location.hash
              .slice(1)
              .split(";")
              .forEach((levelGroup, i) => {
                for (let j = 0; j < levelGroup.length; j += 2) {
                  const country =
                    countries[Number.parseInt(levelGroup.slice(j, j + 2), 16)];
                  setColor(country, i + 1);
                  l[country] = i + 1;
                }
              });
          } catch (err) {
            console.log(err);
            window.location.hash = "";
          }
          total = Object.values(l).reduce((acc, cur) => acc + points[cur], 0);
          document.getElementById("title").innerHTML = `World Level ${total}`;
          document.querySelector("html").style.backgroundColor =
            colorFromLevelMap(l);
          document
            .getElementById("background")
            .setAttribute("fill", colorFromLevelMap(l));

          return l;
        };
        let levelMap = getLevels();

        let highlight = null;
        // highlights a country by making its border have a wider stroke width
        const highlightCountry = (n) => {
          if (highlight !== null) {
            getCountryPaths(highlight).forEach((e) =>
              e.setAttribute("stroke-width", DEFAULT_OUTLINE_STROKE)
            );
          }
          highlight = n;
          getCountryPaths(highlight).forEach((e) =>
            e.setAttribute("stroke-width", HEAVY_OUTLINE_STROKE)
          );
        };
        // updating the level mostly consists of updating the hash,
        // triggering the onhashchange action to reparse the hash entirely
        const setLevel = (countryName, level) => {
          levelMap[countryName] = level;
          // still necessary to change this specific country, as
          // onhashchange will only update the colors of non-0 level countries
          setColor(countryName, level);

          window.location.hash = hashOf(levelMap);
        };

        const selectCountry = (c, e) => {
          highlightCountry(c);
          if (c) {
            console.log("selecting country", c);
            scoreEl.style.top = e.offsetY + 116;
            scoreEl.style.left = e.offsetX;
            scoreEl.removeAttribute("hidden");
            document.getElementById("label").innerText = c;
            for (const svgScoreEl of svgScoreEls) {
              svgScoreEl.setAttribute("visibility", "hidden");
            }
          } else {
            scoreEl.setAttribute("hidden", "hidden");
            for (const svgScoreEl of svgScoreEls) {
              svgScoreEl.setAttribute("visibility", "visible");
            }
          }
        };
        // when clicking in the world map, if clicking on a country,
        // highlight it and move the scores div into place underneath,
        // updating it with the name of the clicked country. Otherwise
        // remove the country name and move it back to its default spot
        document.querySelector("svg").onclick = (e) => {
          const country = e.target.attributes.name
            ? e.target.attributes.name.value
            : e.target.className.baseVal;
          selectCountry(country, e);
        };

        // you can type 0-6 to set the level while a country is highlighted
        document.onkeypress = (e) =>
          highlight !== null &&
          colors[Number.parseInt(e.key)] &&
          setLevel(highlight, Number.parseInt(e.key));

        // if the window.location.hash changed, need to recompute the levels
        window.onhashchange = () => {
          levelMap = getLevels();
        };

        // updates the scoreEl div with the right colors, points labels, and
        // onclick listeners to be able to click in order to annotate the level
        points.forEach((pts, score) => {
          document.getElementById(`score-${score}`).style.background =
            colors[score];
          const ptSpan = document.createElement("span");
          ptSpan.innerHTML = `${pts} pts`;
          const specificScoreEl = document.getElementById(`score-${score}`);
          specificScoreEl.appendChild(ptSpan);
          specificScoreEl.style.cursor = "pointer";
          specificScoreEl.onclick = () =>
            highlight !== null && setLevel(highlight, score);
        });

        const saveImage = () => {
          console.log("saving");
          selectCountry(null);
          const svg = document.querySelector("svg");
          const outputSvg = `
<svg 
  version="1.1"
  xmlns="http://www.w3.org/2000/svg" 
  viewBox="0 0 ${WIDTH} ${HEIGHT}" 
  width="${IMG_WIDTH}px" 
  height="${IMG_HEIGHT}px" 
  fill="#fff" 
  stroke="#000" 
  stroke-width="2px">
  <rect width="100%" height="100%" fill="${colorFromLevelMap(levelMap)}" />
  ${svg.innerHTML}
</svg>`;

          const blob = new Blob([svg.outerHTML], {
            type: "image/svg+xml;charset=utf-8",
          });
          const urlSrc = URL.createObjectURL(blob);
          // save the contents of the svg element as a png file by using a canvas
          const canvas = document.createElement("canvas");
          canvas.width = IMG_WIDTH;
          canvas.height = IMG_HEIGHT;
          const ctx = canvas.getContext("2d");
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, 0, 0, IMG_WIDTH, IMG_HEIGHT);
            const link = document.createElement("a");
            link.download = "world.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
            console.log("saved?", link);
          };
          img.onerror = (e) => console.log("crap", e);
          img.src = urlSrc;
        };
        document.getElementById("save").onclick = saveImage;
        document.getElementById("clear").onclick = () => {
          for (const c in levelMap) {
            if (levelMap[c] > 0) {
              setColor(c, 0);
            }
            levelMap[c] = 0;
          }
          window.location.hash = hashOf(levelMap);
        };
      }
      loadWorld();
    </script>
  </head>
  <body>
    <div id="scores" hidden>
      <div id="label"></div>
      <div id="score-6"><span>Lived Here</span></div>
      <div id="score-5"><span>Stayed Here</span></div>
      <div id="score-4"><span>Visited Here</span></div>
      <div id="score-3"><span>Stopped Here</span></div>
      <div id="score-2"><span>Passed Here</span></div>
      <div id="score-1"><span>Want to be Here</span></div>
      <div id="score-0"><span>Never Been Here</span></div>
    </div>
    <button id="save">Save</button>
    <button id="clear">Clear</button>
  </body>
</html>
